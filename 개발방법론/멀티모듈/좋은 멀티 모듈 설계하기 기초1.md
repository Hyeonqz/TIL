# 좋은 멀티 모듈 설계하기 기초 1

## 목차
- [개요](#개요)
- [왜 멀티 모듈로 프로젝트를 구성할까?](#왜-멀티-모듈로-프로젝트를-구성할까)
- [잘못 나누기 쉬운 기준](#잘못-나누기-쉬운-기준)
- [좋은 멀티 모듈 설계 원칙](#좋은-멀티-모듈-설계-원칙)
- [대표 구조 비교](#대표-구조-비교)
- [중간 규모 실무 추천 구조](#중간-규모-실무-추천-구조)
- [모듈 의존 규칙](#모듈-의존-규칙)
- [실전 체크리스트](#실전-체크리스트)
- [마무리](#마무리)

## 개요
실무에서 멀티 모듈을 도입하면 "코드 분리" 자체보다 "변경 비용"에 대한 고민을 많이 하게 됩니다.
위 문서는 실무에서 레이어 분리 중심 멀티 모듈 접근의 한계를 정리하고, 추후 MSA 전환까지 고려한 현실적인 멀티 모듈 설계 기준을 다룹니다.

## 왜 멀티 모듈로 프로젝트를 구성할까?
멀티 모듈의 목적은 다음 4가지입니다.
- 변경 범위 최소화: 기능 변경 시 영향을 받는 모듈 수를 줄인다.
- 빌드/배포 효율화: 변경된 모듈 중심으로 검증하고 배포한다.
- 팀 협업 안정화: 충돌 지점을 줄이고 책임 경계를 명확히 한다.
- 미래 분리 가능성 확보: 필요 시 서비스 단위(MSA)로 분리하기 쉬운 구조를 만든다.

핵심은 "재사용"보다 "변경 격리"가 우선이라는 점입니다.

## 잘못 나누기 쉬운 기준
### 1) 기술 계층 기준 분리의 함정
다음처럼 기술 레이어로 모듈을 자르면 초기엔 깔끔해 보이지만, 기능 변경 때 비용이 커집니다.

```text
module-controller
module-service
module-repository
```

문제점:
- 결제 기능 1개 변경에도 여러 모듈을 동시에 수정
- 모듈 간 의존이 촘촘해져 독립 배포 가치가 낮아짐
- 결과적으로 "물리적으로만 분리된 단일 모놀리식"이 되기 쉬움

### 2) 무분별한 common/shared 비대화
`module-common`, `module-shared`는 편리하지만, 기준 없이 키우면 결합점이 됩니다.
- 공통 모듈 변경이 전체 재빌드/재배포를 유발
- 도메인 규칙이 공통 모듈로 새어 나감
- "모두가 의존하는 모듈"이 병목이 됨

실무에서 특히 위 두 문제(레이어 기준 분리, 공통 모듈 비대화)가 반복적으로 발생합니다.


## 좋은 멀티 모듈 설계 원칙
### 1. CCP (Common Closure Principle)
"같은 이유로 변경되는 것"은 같은 모듈에 둡니다.
- 결제 정책 변경 → `payment` 계열 모듈에서 닫혀야 함
- 정산/알림 모듈은 영향이 없어야 함

### 2. ADP (Acyclic Dependencies Principle)
순환 의존을 금지합니다.

```text
금지: payment -> settlement -> payment
허용: payment -> settlement
```

순환이 생기면 사실상 하나의 모듈입니다.

### 3. SDP (Stable Dependencies Principle)
자주 바뀌는 모듈이 덜 바뀌는 모듈에 의존해야 합니다.
- `domain-*(자주 바뀜)` -> `platform-*(자주 안바뀜)` 방향은 가능
- `platform-*` -> `domain-*` 방향은 금지

### 4. DIP (Dependency Inversion Principle)
구현이 아닌 인터페이스에 의존합니다.

```kotlin
// domain-payment
interface PaymentNotifier {
    fun notify(event: PaymentEvent)
}

// payment-infra
class SlackPaymentNotifier : PaymentNotifier {
    override fun notify(event: PaymentEvent) {
        // ...
    }
}
```

도메인은 구현체를 모르고, 인프라가 구현을 제공합니다.

### 5. 모듈 API 최소 공개
모듈 외부 진입점만 `public`, 내부 구현은 숨깁니다.
- 공개 API: Facade, UseCase, Command/Query DTO
- 비공개: 도메인 내부 서비스, 구현 상세, 영속성 세부사항

## 대표 구조 비교
### A. 레이어형 분리 (`domain`, `infra`, `shared`)
장점:
- 진입이 쉽고 학습 비용이 낮음
- 작은 팀에서 빠르게 시작 가능

단점:
- 기능 변경이 레이어를 가로질러 발생
- 모듈 경계가 기술 기준이라 MSA 분리 기준과 어긋날 수 있음
- `shared` 비대화 위험이 큼

적합:
- 도메인 복잡도가 낮고 서비스 수명이 짧은 경우


### B. 도메인 중심 수평 분리 (`payment`, `settlement`, `notification`)
장점:
- 변경 이유 기준 경계와 잘 맞음
- 팀 책임 분리가 명확함
- 특정 도메인만 분리 배포/확장하기 쉬움

단점:
- 초기 설계 난이도 상승
- 도메인 간 계약(이벤트/인터페이스) 관리 필요

적합:
- 도메인 복잡도가 높고 장기 운영하는 서비스

## 중간 규모 실무 추천 구조

> 도메인 = Bounded Context = 독립 배포 가능한 단위

각 도메인 모듈은 **"혼자서도 의미가 있는 비즈니스 단위"** 여야 합니다.

```text
❌ 잘못된 분리
module-payment-controller
module-payment-service
module-payment-repository

→ 셋이 함께 있어야만 의미가 있음
→ 독립 배포 불가능

✅ 올바른 분리
domain-payment/
├── payment-core      ← 비즈니스 로직
├── payment-infra     ← 기술 구현
└── payment-api       ← 도메인 공개 인터페이스(UseCase 계약)

→ 이 도메인 하나로 "결제 서비스" 완성
→ 언제든 독립 서비스로 분리 가능
```

### 핀테크 Payment Gateway 기준
```java
payment-gateway/
├── platform/
│   ├── platform-common              # 순수 VO (Money, TransactionId)
│   ├── platform-support             # Spring 횡단 관심사
│   └── platform-infrastructure      # Redis, Kafka 공통 설정
│
├── domain/
│   ├── payment/
│   │   ├── payment-core             # 도메인 로직, Repository 인터페이스
│   │   ├── payment-infra            # JPA, PG사 연동 구현
│   │   └── payment-api              # 공개 UseCase/Facade, Command/Query DTO
│   ├── settlement/
│   │   ├── settlement-core
│   │   ├── settlement-infra
│   │   └── settlement-api
│
└── application/
    ├── app-merchant-api             # 가맹점용 REST 진입점 (Controller)
    └── app-internal-api             # 내부 통신 진입점
```
```java
payment-gateway/
├── platform/                     ← jar 라이브러리
│   ├── platform-common           ← jar로 빌드 (배포 X)
│   └── platform-support          ← jar로 빌드 (배포 X)
│
├── domain/                       ← jar 라이브러리
│   ├── payment/
│   │   ├── payment-core          ← jar로 빌드 (배포 X)
│   │   ├── payment-infra         ← jar로 빌드 (배포 X)
│   │   └── payment-api           ← jar로 빌드 (배포 X)
│   └── settlement/
│       ├── settlement-core       ← jar로 빌드 (배포 X)
│       ├── settlement-infra      ← jar로 빌드 (배포 X)
│       └── settlement-api        ← jar로 빌드 (배포 X)
│
└── application/                  ← 실행 가능 (배포 대상)
    ├── app-api                   ← 실행 가능한 jar (배포 O)
    ├── app-socket                ← 실행 가능한 jar (배포 O)
    └── app-scheduler             ← 실행 가능한 jar (배포 O)
```


### 의존성 규칙
- application(`app-*`) → `domain-*-api` 의존
- `domain-*-api` → `domain-*-core` 의존
- `domain-*-infra` → `domain-*-core` + `platform-*` 의존
- `domain-*-core` → `platform-common` 같은 안정 모듈만 의존
- `domain-*-core`는 `infra/api/spring`에 의존하지 않음
- domain 간 통신은 이벤트 또는 application 서비스 조율

### 참고 예시 (가상의 구조)
아래 구조는 특정 회사의 실제 내부 구조를 단정한 예시가 아니라, 본 문서 원칙을 설명하기 위한 가상 예시입니다.

```java
payment-platform/
│
├── platform/                        
│   ├── platform-common              ← Money, TransactionId 같은 불변 VO
│   ├── platform-support             ← Spring 공통 (Filter, Logger)
│   └── platform-infrastructure      ← Redis, Kafka 공통 설정
│
├── domain/                          ← 각 도메인은 완전 독립
│   ├── payment/
│   │   ├── payment-core             ← 도메인 로직 (Entity, Service, Repository 인터페이스)
│   │   ├── payment-infra            ← JPA, PG사 연동 구현체
│   │   └── payment-api              ← 공개 UseCase/Facade
│   │
│   ├── settlement/
│   │   ├── settlement-core
│   │   ├── settlement-infra
│   │   └── settlement-api
│   │
│   └── fraud-detection/             ← 부정거래 탐지
│       ├── fraud-core
│       ├── fraud-infra
│       └── fraud-api
│
└── application/                     ← 서비스 조합 레이어
    ├── app-merchant-api             ← 가맹점 대상 REST API 진입점
    ├── app-internal-api             ← 내부 서비스 간 통신
    └── app-batch                    ← 정산 배치
```
- `domain-*` 모듈은 **완전히 독립된 Bounded Context**
- 각 도메인은 `core`, `infra`, `api`로 다시 수직 분리
- `application` 계층이 도메인들을 **조율**


## 모듈 의존 규칙
의존 방향은 반드시 단방향으로 고정합니다.

- 도메인 간 통신은 인터페이스/이벤트/애플리케이션 서비스 경유
- cross-domain 데이터 공유는 "복제" 또는 "조회 전용 계약"으로 처리

## 실전 체크리스트
모듈 신설 전:
- 이 모듈은 어떤 이유로 변경되는가?
- 기존 모듈과 변경 이유가 같은가, 다른가?
- 독립 테스트가 가능한가?
- 의존 방향이 단방향인가?
- 이 모듈이 미래에 독립 배포 단위가 될 수 있는가?

설계 이상 신호:
- 기능 1개 추가에 3개 이상 모듈 동시 수정
- `shared/common`이 계속 커짐
- 항상 함께 배포되는 모듈 쌍이 있음
- 순환 의존을 인터페이스 모듈로 억지 봉합함

## 마무리
잘 설계된 멀티 모듈은 "현재 변경 비용을 줄이면서, 미래 분리 비용도 낮추는 구조"입니다.

요약:
- 모듈 경계는 기술 레이어가 아니라 변경 이유(CCP)로 나눈다.
- 의존은 단방향(ADP) + 안정성 방향(SDP)을 지킨다.
- 도메인 로직은 코어에, 인프라는 바깥으로 밀어낸다(DIP).
- API 진입점(Controller)은 `application`에 두고, 도메인 API는 공개 유스케이스 계약으로 유지한다.
- 목표는 "필요할 때 서비스로 분리 가능한 모듈"이다.

### REF
- https://www.youtube.com/watch?v=VPzg61njKxw&t=1141s
