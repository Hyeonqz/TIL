# JPA 엔티티와 실제 DB 외래키 전략 궁금증

한 가지 궁금한 내용이 있어 위 내용을 실험해보고 난 결과를 정리해보았다 <br>

> 개발 환경은 SpringBoot, MySQL, JPA 를 사용중이다.

실무를 하다보니 여러 테이블들이 외래키로 엮여있으면 여간 불편한점이 많았다 <br>
그래서 이번에 테이블 설계를 할 일이 생겨서 테이블 설계를 진행해보았다 <br>

설계한 테이블은 당연하게도 다른 테이블과 엮여 있는 데이터가 있었고, Join 을 하여 데이터를 가져올 수 있게 설계를 해야했다 <br>

JPA 를 사용하는 나로써는 Entity 설계시, 연관관계에 대한 설계를 처음 생각하였다 <br>
그다음 고민은 테이블 정규화에 대한 고민을 하였다 <br>

> 참고로 JPA 설정 중에 ddl-auto 설정은 none 으로 하여 진행 한다. <br>

테이블 설계를 한 후에 이제 엔티티를 만들려고 하였는데, 문득 생각이 들었다 <br>
설계대로 엔티티를 만들고 @ManyToOne, @OneToMany @JoinColumns 등 위 어노테이션을 사용해서 연관관계를 맺으면 당연하게도, 외래키 전략이 포함이 될 것이다 <br>

기존에 생성된 테이블이야 건들려면 대규모 작업이 될 것이라, 운영에 문제가 생길까봐 일단은 냅두고, <br>
새로 생성하는 테이블이라도 외래키 전략을 줄여보고 싶었다 <br>

조금 찾아본 데이터로는 JPA @JoinColumn 옵션 중에, foreignKey 생성을 하지않게 하는 옵션이 있었다. <br>
그리고 다른 방법으로는 객체로 관리하는 것이 아닌 Long 타입에 'id' 를 통하여 관리하는 방법이였다 <br>
위 방법을 토대로 궁금한 내용을 직접 적용해보며 경험한 내용을 남겨보려고 한다. <br>


#### 1. JPA 에서 연관관계를 맺음 -> 실제 DB 에서는 외래키가 생성되어 있지 않음.

```java
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@Table(name = "orders")
@Entity
public class Order {

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long id;

	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "member_id")
	private Member member;
}

@NoArgsConstructor(access = AccessLevel.PROTECTED)
@Entity
public class Member {

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long id;
	
}
```

위 엔티티를 생성 후 어플리케이션 실행시 아래와 같은 SQL 이 자동으로 나간다 <br>

```sql
create table member
(
   id       bigint generated by default as identity,
   primary key (id)
)

create table orders
(
    id        bigint generated by default as identity,
    member_id bigint,
    primary key (id)
)

alter table if exists orders
    add constraint FKpktxwhj3x9m4gth5ff6bkqgeb
    foreign key (member_id)
    references member
```

생각한 대로, 2개의 테이블이 생성되고, 연관관계에 알맞게 FK 조건이 생성이 된다 <br>
위 FK 는 orders 테이블에 member 테이블에 대한 제약 조건이 걸리게 되어있다 <br>


#### 가장 쉬운 방법으로 FK 조건을 없애보자 <br>
Order 엔티티에 옵션을 추가하였다
```java
	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "member_id", foreignKey = @ForeignKey(ConstraintMode.NO_CONSTRAINT))
	private Member member;
```

- foreignKey = @ForeignKey(ConstraintMode.NO_CONSTRAINT) 위 조건을 주었다.

위 전략을 사용하면 어플리케이션 내부에서, 객체 지향적인 연관관계를 유지하면서도 데이터베이스에 물리적인 외래 키(FK) 제약 조건을 생성하지 않도록 설정할 수 있습니다
```sql
Hibernate: 
    create table member (
        id bigint generated by default as identity,
        name varchar(255),
        phone_number varchar(255),
        primary key (id)
    )
Hibernate: 
    create table order (
        create_at timestamp(6),
        id bigint generated by default as identity,
        member_id bigint,
        primary key (id)
    )
```


#### 2. JPA 에서 연관관계를 맺지 않고, id 를 생성해서 관리함 -> 실제 DB 에서 외래키가 생성되어 있지 않음.
일단 위 전략을 사용할 때 장점은

1. FK 제약 조건을 제거하여 유연성 확보
2. 성능 향상 및 JOIN 최소화
   - FK는 조회 성능에는 큰 영향을 주지 않으나, 주로 대량 삭제/수정 시 성능에 영향을 줄 수 있음.

대표적으로 2가지가 있다고 생각한다. <br>

단점은 아래와 같다.
1. 데이터 무결성 보장이 어려움
   - 위 문제는 어플리케이션에서 로직을 통하여 해결해야 한다 -> 로직이 조금 길어진다.
2. 데이터 삭제 시 참조된 데이터가 남아있을 수 있음
   - 연관관계시 옵션 설정을 통하여 작업이 되게 할 수 있지만 위 경우는 불가능함.
3. Join 필요시 코드가 복잡해짐.
    - 연관관계 설정시 간단하게 해결할 일을 JPQL 로 따로 join 쿼리를 작성해야함.

이제 아래 코드를 봐보자.

```java
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@Entity
public class Order2 {

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long id;

	private LocalDateTime createAt;

	private Long memberId;
}

@NoArgsConstructor(access = AccessLevel.PROTECTED)
@Entity
public class Member2 {

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long id;

	private String name;
	private String phoneNumber;

	public Member2 (String name, String phoneNumber) {
		this.name = name;
		this.phoneNumber = phoneNumber;
	}
}
```

```sql
Hibernate:
    create table order2 (
        create_at timestamp(6),
        id bigint generated by default as identity,
        member_id bigint,
        primary key (id)
    )
    
Hibernate: 
    create table member2 (
        id bigint generated by default as identity,
        name varchar(255),
        phone_number varchar(255),
        primary key (id)
    )
```

위 처럼 엔티티를 설계하고 어플리케이션 실행을 시키면 위 create 문이 생성이 된다 <br>
제약조건은 당연히 없다.


-> 그러면 위 처럼 할시 member2 테이블에 PK 인 id 가 이름이 member_id 가 되야하나??
아니면 member_id 라는 식별자를 가진 컬럼이 또 필요한가??


### 결국 FK 쓰지말라는건가?? 
사용했을 때의 장점과 단점이 뚜렷하다 <br>
실무에서는 보통 개념적으로는 당연히 사용을 하지만 물리적으로는 거의 안쓰는 걸로 알고있다 (내 경험으로는 그렇다) <br>

FK 를 사용하게 되면 삭제/수정 시 연관 데이터를 보통 한꺼번에 작업이 된다 <br>
하지만 FK 를 사용하지 않았을 때 위 작업시 데이터 정합성을 신중하게 잘 맞춰야 한다 <br>
그리고 대규모 분산 시스템에서는 보통 FK 대신 이벤트 기반으로 데이터 정합성을 유지한다 <br>

대규모 시스템 또는 데이터가 많을 때는 FK 가 없는 것이 성능상 이점 또한 있다 <br>

**정리하자면, FK 제약 조건은 데이터 무결성을 보장하는 강력한 도구는 맞다.**  
하지만 복잡한 시스템에서는 FK가 오히려 장애 요소가 될 수 있다 <br>

- **작은 규모의 시스템:** FK를 통해 무결성을 쉽게 관리 가능
- **대규모 분산 시스템:** FK 없이 유연성을 확보하되, 애플리케이션 레벨에서 데이터 정합성을 관리

**결국 중요한 것은 "FK를 사용할 것인가?"가 아니라, "어떤 방식으로 데이터의 정합성을 유지할 것인가?"에 대한 의문을 가져야 한다..**  

나는 FK 를 최대한 지양한다.... <br>
그러므로 연관관계를 사용하되, FK 옵션은 없게 사용하는걸 추천한다.
